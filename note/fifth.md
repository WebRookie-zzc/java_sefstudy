# fifth 

## 还是运算符

补充一个代码：


```java
public class first{
    public static void main(String[] ares){
        int x = 1;
        System.out.println(x++);
        //这里的输出是1
    }
}
```


### 关系(比较)运算符：

> < >= <= != == (对象 instanceof 类) ：判断一个对象是否为这个类型的
他们的最终结果是：boolen  (true 和 false)

### 逻辑运算：

&(逻辑与)  |逻辑或   ^逻辑异或   !逻辑非   && 短路与   ||短路或

逻辑符前后链接的是两个Boolean的结果，他们的结果也都是Boolean类型

- 异或^ : 当前后的Boolean结果不同的时候，返回true (即一个true 一个 false)

短路与 &&  当第一个条件为flase时，发生短路，第二个条件就不会再执行
短路或 || 差不多

而&不会发生短路

比较下面的两个代码


```java
public class first{
    public static void main(String[] args){
        int a = 1;
        if((3>4)&(a++ == 1)){}
        System.out.println(a);
        //输出的值为2
    }
}
```


```java
public class first{
    public static void main(String[] args){
        int a = 1;
        if((3>4)&&(a++ == 1)){}
        System.out.println(a);
        //输出的值为1
    }
}
```


### 位运算(用来计算二进制)

&按位与   |按位或   ^按位异或   ~按位取反   
<< 按位左位移   >>按位又位移   >>>按位右位移(无符号)   <<<按位左位移(无符号)

3&5的运算过程：
1.先将3和5转化成二进制的形式
2.竖着按照对应位置进行&|^计算(1当做true,0当做false)
3.将计算后的结果转化成十进制

原码 反码 补码
6的原码： 00000000 00000000 00000000 00000110
补码：    00000000 00000000 00000000 00000110(和原码和补码一样)
补码：    00000000 00000000 00000000 00000110

-6的原码：10000000 00000000 00000000  00000110
反码(保持符号位不动的情况下取反)：11111111 11111111 11111111 11111001
补码：(补码即使负数的反码加一)：11111111 11111111 11111111 11111010
不管是正数还是负数，计算机都是以补码的形式进行存储的

```6<<2```:表示香左移动一位，右侧补零(保留符号位不动)
左移一位相当于原来的数乘二，右移一位除以二
```6<<<2```:符号位不保留